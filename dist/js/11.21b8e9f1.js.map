{"version":3,"file":"js/11.21b8e9f1.js","mappings":"6FAAAA,EAAOC,QAAUC,KAAKC,QAAUD,KAAKC,MAAQC,EAAAA,MAAAA,YAA8BA,EAAQ,M,yFCApE,WAASC,EAAKC,GAAA,OAC5BA,EAAUA,GAAW,CAAC,EACf,IAAIC,SAAA,SAAUC,EAASC,GAAA,IACvBC,EAAU,IAAIC,eACdC,EAAO,GACPC,EAAM,GACNC,EAAU,CAAC,EAEXC,EAAA,kBACLC,GAA8B,IAAzBN,EAAQO,OAAO,IAAI,GACxBC,WAAYR,EAAQQ,WACpBD,OAAQP,EAAQO,OAChBE,IAAKT,EAAQU,YACbC,KAAA,kBAAYd,QAAQe,QAAQZ,EAAQa,aAAA,EACpCC,KAAA,kBAAYjB,QAAQe,QAAQZ,EAAQa,cAAcE,KAAKC,KAAKC,MAAA,EAC5DC,KAAA,kBAAYrB,QAAQe,QAAQ,IAAIO,KAAK,CAACnB,EAAQoB,WAAA,EAC9CC,MAAOhB,EACPiB,QAAS,CACRC,KAAA,kBAAYrB,CAAA,EACZsB,QAAA,kBAAerB,CAAA,EACfsB,IAAA,SAAK9B,GAAA,OAAKS,EAAQT,EAAE+B,cAAA,EACpBC,IAAA,SAAKhC,GAAA,OAAKA,EAAE+B,gBAAiBtB,CAAA,SAmB1B,IAAMwB,KAfX5B,EAAQ6B,KAAKjC,EAAQkC,QAAU,MAAOnC,GAAA,GAEtCK,EAAQ+B,OAAA,WACP/B,EAAQgC,wBAAwBC,QAAQ,gCAAgC,SAACtC,EAAGC,EAAKE,GAChFI,EAAKgC,KAAKtC,EAAMA,EAAI8B,eACpBvB,EAAI+B,KAAK,CAACtC,EAAKE,IACfM,EAAQR,GAAOQ,EAAQR,GAAUQ,EAAQR,GAAA,IAAQE,EAAUA,CAAA,IAE5DA,EAAQO,IAAA,EAGTL,EAAQmC,QAAUpC,EAElBC,EAAQoC,gBAAuC,WAArBxC,EAAQyC,YAElBzC,EAAQ0B,QACvBtB,EAAQsC,iBAAiBV,EAAGhC,EAAQ0B,QAAQM,IAG7C5B,EAAQuC,KAAK3C,EAAQ4C,MAAQ,S","sources":["webpack://indfer/./node_modules/isomorphic-unfetch/browser.js","webpack://indfer/../src/index.mjs"],"sourcesContent":["module.exports = self.fetch || (self.fetch = require('unfetch').default || require('unfetch'));\n","export default function(url, options) {\n\toptions = options || {};\n\treturn new Promise( (resolve, reject) => {\n\t\tconst request = new XMLHttpRequest();\n\t\tconst keys = [];\n\t\tconst all = [];\n\t\tconst headers = {};\n\n\t\tconst response = () => ({\n\t\t\tok: (request.status/100|0) == 2,\t\t// 200-299\n\t\t\tstatusText: request.statusText,\n\t\t\tstatus: request.status,\n\t\t\turl: request.responseURL,\n\t\t\ttext: () => Promise.resolve(request.responseText),\n\t\t\tjson: () => Promise.resolve(request.responseText).then(JSON.parse),\n\t\t\tblob: () => Promise.resolve(new Blob([request.response])),\n\t\t\tclone: response,\n\t\t\theaders: {\n\t\t\t\tkeys: () => keys,\n\t\t\t\tentries: () => all,\n\t\t\t\tget: n => headers[n.toLowerCase()],\n\t\t\t\thas: n => n.toLowerCase() in headers\n\t\t\t}\n\t\t});\n\n\t\trequest.open(options.method || 'get', url, true);\n\n\t\trequest.onload = () => {\n\t\t\trequest.getAllResponseHeaders().replace(/^(.*?):[^\\S\\n]*([\\s\\S]*?)$/gm, (m, key, value) => {\n\t\t\t\tkeys.push(key = key.toLowerCase());\n\t\t\t\tall.push([key, value]);\n\t\t\t\theaders[key] = headers[key] ? `${headers[key]},${value}` : value;\n\t\t\t});\n\t\t\tresolve(response());\n\t\t};\n\n\t\trequest.onerror = reject;\n\n\t\trequest.withCredentials = options.credentials=='include';\n\n\t\tfor (const i in options.headers) {\n\t\t\trequest.setRequestHeader(i, options.headers[i]);\n\t\t}\n\n\t\trequest.send(options.body || null);\n\t});\n}\n"],"names":["module","exports","self","fetch","require","e","n","Promise","t","r","s","XMLHttpRequest","o","u","i","a","ok","status","statusText","url","responseURL","text","resolve","responseText","json","then","JSON","parse","blob","Blob","response","clone","headers","keys","entries","get","toLowerCase","has","l","open","method","onload","getAllResponseHeaders","replace","push","onerror","withCredentials","credentials","setRequestHeader","send","body"],"sourceRoot":""}